import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
import queue
import time
from datetime import datetime
import string
import random
import itertools
import hashlib
from enum import Enum

class AccountStatus(Enum):
    ACTIVE = "active"
    LOCKED = "locked"
    RATE_LIMITED = "rate_limited"

class DummyLoginSystem:
    """A dummy login system that can be used to test password strength with security features."""
    
    def __init__(self, real_password, rate_limiting=True, lockout_threshold=5, 
                 base_delay=1.0, max_delay=60.0, lockout_duration=300):
        self.real_password = real_password
        self.login_attempts = 0
        self.failed_attempts = 0
        self.consecutive_failures = 0
        self.last_attempt_time = 0
        self.account_status = AccountStatus.ACTIVE
        self.lockout_start_time = 0
        
        # Rate limiting settings
        self.rate_limiting = rate_limiting
        self.base_delay = base_delay
        self.max_delay = max_delay
        
        # Account lockout settings
        self.lockout_threshold = lockout_threshold
        self.lockout_duration = lockout_duration
        
    def attempt_login(self, password_guess):
        """Simulate a login attempt with the given password."""
        current_time = time.time()
        
        # Check if account is locked
        if self.account_status == AccountStatus.LOCKED:
            if current_time - self.lockout_start_time < self.lockout_duration:
                return False, "Account locked"
            else:
                # Unlock account after lockout duration
                self.account_status = AccountStatus.ACTIVE
                self.consecutive_failures = 0
        
        # Apply rate limiting delay
        if self.rate_limiting and self.last_attempt_time > 0:
            # Calculate progressive delay based on consecutive failures
            delay = min(self.base_delay * (2 ** self.consecutive_failures), self.max_delay)
            elapsed = current_time - self.last_attempt_time
            
            if elapsed < delay:
                sleep_time = delay - elapsed
                time.sleep(sleep_time)
        
        self.login_attempts += 1
        self.last_attempt_time = time.time()
        
        # Check password
        success = password_guess == self.real_password
        
        if success:
            self.consecutive_failures = 0
            self.account_status = AccountStatus.ACTIVE
            return True, "Login successful"
        else:
            self.failed_attempts += 1
            self.consecutive_failures += 1
            
            # Check for account lockout
            if self.consecutive_failures >= self.lockout_threshold:
                self.account_status = AccountStatus.LOCKED
                self.lockout_start_time = time.time()
                return False, "Account locked due to too many failed attempts"
            
            return False, "Invalid password"
        
    def get_attempts(self):
        """Return the number of login attempts made."""
        return self.login_attempts
    
    def get_status(self):
        """Return current account status."""
        return self.account_status
    
    def reset_lockout(self):
        """Reset account lockout (admin function)."""
        self.account_status = AccountStatus.ACTIVE
        self.consecutive_failures = 0
        self.lockout_start_time = 0

class RainbowTable:
    """Simulates a rainbow table with pre-computed hashes."""
    
    def __init__(self):
        self.hash_table = {}
        self._generate_common_hashes()
    
    def _generate_common_hashes(self):
        """Generate hashes for common passwords."""
        common_passwords = [
            'password', '123456', 'qwerty', 'admin', 'welcome', 'login',
            'abc123', 'letmein', 'master', 'hello', 'monkey', 'password123',
            'test', 'football', 'baseball', '1234', '12345', '123456789',
            'password1', 'iloveyou', 'princess', 'rockyou', 'abc123',
            'nicole', 'daniel', 'babygirl', 'monkey', 'lovely', 'jessica'
        ]
        
        # Add variations
        variations = []
        for pwd in common_passwords:
            variations.extend([
                pwd.upper(),
                pwd.capitalize(),
                pwd + '!',
                pwd + '123',
                pwd + '1',
                pwd + '2023',
                pwd + '2024',
                pwd + '2025'
            ])
        
        all_passwords = common_passwords + variations
        
        for pwd in all_passwords:
            # Store MD5 hash (just for simulation)
            hash_value = hashlib.md5(pwd.encode()).hexdigest()
            self.hash_table[hash_value] = pwd
    
    def lookup(self, password_hash):
        """Look up a password hash in the rainbow table."""
        return self.hash_table.get(password_hash)
    
    def crack_password(self, password):
        """Attempt to crack a password using the rainbow table."""
        password_hash = hashlib.md5(password.encode()).hexdigest()
        return self.lookup(password_hash)

class SocialEngineeringWordlist:
    """Generate wordlists based on social engineering patterns."""
    
    @staticmethod
    def generate_personal_patterns(first_name="", last_name="", birth_year="", 
                                 company="", pet_name="", city=""):
        """Generate passwords based on personal information."""
        patterns = []
        
        # Basic personal info
        if first_name:
            patterns.extend([
                first_name,
                first_name.capitalize(),
                first_name.lower(),
                first_name.upper()
            ])
        
        if last_name:
            patterns.extend([
                last_name,
                last_name.capitalize(),
                last_name.lower(),
                last_name.upper()
            ])
        
        # Name combinations
        if first_name and last_name:
            patterns.extend([
                first_name + last_name,
                first_name.capitalize() + last_name.capitalize(),
                first_name[0].lower() + last_name.lower(),
                last_name.lower() + first_name[0].lower()
            ])
        
        # Add common suffixes to base patterns
        base_patterns = patterns.copy()
        common_suffixes = ['123', '1', '!', '2023', '2024', '2025', '01', '00']
        
        for base in base_patterns:
            for suffix in common_suffixes:
                patterns.append(base + suffix)
        
        # Birth year patterns
        if birth_year:
            for base in base_patterns:
                patterns.extend([
                    base + birth_year,
                    base + birth_year[-2:],  # Last 2 digits
                    birth_year + base
                ])
        
        # Company patterns
        if company:
            company_patterns = [company, company.lower(), company.capitalize()]
            patterns.extend(company_patterns)
            for comp in company_patterns:
                for suffix in common_suffixes:
                    patterns.append(comp + suffix)
        
        # Pet/city patterns
        for personal_info in [pet_name, city]:
            if personal_info:
                info_patterns = [personal_info, personal_info.lower(), personal_info.capitalize()]
                patterns.extend(info_patterns)
                for info in info_patterns:
                    for suffix in common_suffixes:
                        patterns.append(info + suffix)
        
        return list(set(patterns))  # Remove duplicates

class MaskAttack:
    """Implement mask-based attacks for specific password patterns."""
    
    @staticmethod
    def generate_mask_patterns():
        """Generate common password masks."""
        masks = [
            "?l?l?l?l?d?d",          # 4 letters + 2 digits
            "?l?l?l?l?d?d?d",        # 4 letters + 3 digits
            "?u?l?l?l?l?d?d",        # Capital + 4 letters + 2 digits
            "?l?l?l?l?l?d?d",        # 5 letters + 2 digits
            "?l?l?l?l?l?l?d?d",      # 6 letters + 2 digits
            "?u?l?l?l?l?l?l?d?d",    # Capital + 6 letters + 2 digits
            "?l?l?l?l?s",            # 4 letters + special char
            "?u?l?l?l?l?l?l?s",      # Capital + 6 letters + special
            "?d?d?d?d?d?d",          # 6 digits
            "?l?l?l?l?l?l?l?l",      # 8 letters
        ]
        return masks
    
    @staticmethod
    def expand_mask(mask, max_combinations=1000):
        """Expand a mask pattern into actual password candidates."""
        # Character sets for mask patterns
        char_sets = {
            '?l': string.ascii_lowercase,
            '?u': string.ascii_uppercase,
            '?d': string.digits,
            '?s': '!@#$%^&*'
        }
        
        # Parse mask into components
        components = []
        i = 0
        while i < len(mask):
            if i < len(mask) - 1 and mask[i:i+2] in char_sets:
                components.append(char_sets[mask[i:i+2]])
                i += 2
            else:
                components.append([mask[i]])
                i += 1
        
        # Generate combinations (limited to prevent memory issues)
        passwords = []
        count = 0
        
        for combo in itertools.product(*components):
            if count >= max_combinations:
                break
            passwords.append(''.join(combo))
            count += 1
        
        return passwords

class RuleBasedAttack:
    """Apply transformation rules to dictionary words."""
    
    @staticmethod
    def apply_rules(word_list, max_variations_per_word=20):
        """Apply various transformation rules to words."""
        transformed_words = set()
        
        rules = [
            # Capitalization rules
            lambda w: w.capitalize(),
            lambda w: w.upper(),
            lambda w: w.lower(),
            lambda w: w.swapcase(),
            
            # Leetspeak substitutions
            lambda w: w.replace('a', '@').replace('e', '3').replace('i', '1').replace('o', '0').replace('s', '$'),
            lambda w: w.replace('a', '4').replace('e', '3').replace('i', '!').replace('o', '0').replace('s', '5'),
            
            # Append common patterns
            lambda w: w + '123',
            lambda w: w + '1',
            lambda w: w + '!',
            lambda w: w + '2023',
            lambda w: w + '2024',
            lambda w: w + '2025',
            lambda w: w + '01',
            lambda w: '1' + w,
            lambda w: '!' + w,
            
            # Reverse
            lambda w: w[::-1],
            
            # Double
            lambda w: w + w,
            
            # Remove vowels
            lambda w: ''.join([c for c in w if c.lower() not in 'aeiou']),
            
            # First and last character manipulation
            lambda w: w[0].upper() + w[1:] if len(w) > 1 else w.upper(),
            lambda w: w[:-1] + w[-1].upper() if len(w) > 1 else w.upper(),
        ]
        
        for word in word_list:
            variations_count = 0
            for rule in rules:
                if variations_count >= max_variations_per_word:
                    break
                try:
                    transformed = rule(word)
                    if transformed and transformed != word:
                        transformed_words.add(transformed)
                        variations_count += 1
                except:
                    continue  # Skip if rule fails
        
        return list(transformed_words)

class PasswordStrengthGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Password Strength Tester")
        self.root.geometry("1000x800")
        self.root.configure(bg='#2b2b2b')
        
        # Configure style
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.configure_styles()
        
        # Queue for thread communication
        self.queue = queue.Queue()
        
        # Testing state
        self.is_testing = False
        self.test_thread = None
        
        self.create_widgets()
        self.check_queue()
        
    def configure_styles(self):
        """Configure custom styles for the application."""
        self.style.configure('Title.TLabel', 
                           font=('Arial', 16, 'bold'), 
                           background='#2b2b2b', 
                           foreground='#ffffff')
        
        self.style.configure('Header.TLabel', 
                           font=('Arial', 12, 'bold'), 
                           background='#2b2b2b', 
                           foreground='#ffffff')
        
        self.style.configure('Custom.TLabel', 
                           background='#2b2b2b', 
                           foreground='#ffffff')
        
        self.style.configure('Custom.TButton',
                           font=('Arial', 10, 'bold'))
        
        self.style.configure('Custom.TEntry',
                           font=('Arial', 10))
        
        self.style.configure('Custom.TCheckbutton',
                           background='#2b2b2b',
                           foreground='#ffffff',
                           font=('Arial', 10))
        
    def create_widgets(self):
        """Create and arrange all GUI widgets."""
        # Main container
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Title
        title_label = ttk.Label(main_frame, text="Password Strength Tester", 
                               style='Title.TLabel')
        title_label.pack(pady=(0, 20))
        
        # Create notebook for tabs
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill='both', expand=True)
        
        # Test tab
        self.test_frame = ttk.Frame(notebook)
        notebook.add(self.test_frame, text="Test Password")
        self.create_test_tab()
        
        # Generator tab
        self.generator_frame = ttk.Frame(notebook)
        notebook.add(self.generator_frame, text="Password Generator")
        self.create_generator_tab()
        
        # Results tab
        self.results_frame = ttk.Frame(notebook)
        notebook.add(self.results_frame, text="Results")
        self.create_results_tab()
        
    def create_test_tab(self):
        """Create the password testing tab."""
        # Password input section
        input_frame = ttk.LabelFrame(self.test_frame, text="Password Input", padding=10)
        input_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Label(input_frame, text="Enter password to test:", 
                 style='Custom.TLabel').pack(anchor='w')
        
        self.password_var = tk.StringVar()
        password_frame = ttk.Frame(input_frame)
        password_frame.pack(fill='x', pady=(5, 0))
        
        self.password_entry = ttk.Entry(password_frame, textvariable=self.password_var,
                                       show='*', font=('Arial', 12), style='Custom.TEntry')
        self.password_entry.pack(side='left', fill='x', expand=True)
        
        self.show_password_var = tk.BooleanVar()
        show_btn = ttk.Checkbutton(password_frame, text="Show", 
                                  variable=self.show_password_var,
                                  command=self.toggle_password_visibility,
                                  style='Custom.TCheckbutton')
        show_btn.pack(side='right', padx=(5, 0))
        
        # Security settings section
        security_frame = ttk.LabelFrame(self.test_frame, text="Security Settings", padding=10)
        security_frame.pack(fill='x', pady=(0, 10))
        
        # Rate limiting
        self.rate_limiting_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(security_frame, text="Enable Rate Limiting (Recommended)",
                       variable=self.rate_limiting_var,
                       style='Custom.TCheckbutton').pack(anchor='w')
        
        # Lockout threshold
        lockout_frame = ttk.Frame(security_frame)
        lockout_frame.pack(fill='x', pady=(5, 0))
        
        ttk.Label(lockout_frame, text="Account Lockout Threshold:",
                 style='Custom.TLabel').pack(side='left')
        
        self.lockout_threshold_var = tk.StringVar(value="5")
        lockout_spinbox = ttk.Spinbox(lockout_frame, from_=1, to=20, width=5,
                                     textvariable=self.lockout_threshold_var)
        lockout_spinbox.pack(side='left', padx=(5, 0))
        
        ttk.Label(lockout_frame, text="attempts",
                 style='Custom.TLabel').pack(side='left', padx=(5, 0))
        
        # Attack types section
        attacks_frame = ttk.LabelFrame(self.test_frame, text="Attack Types", padding=10)
        attacks_frame.pack(fill='x', pady=(0, 10))
        
        # Create checkboxes for attack types
        self.attack_vars = {}
        attacks = [
            ('rainbow_table', 'Rainbow Table Attack'),
            ('social_engineering', 'Social Engineering Attack'),
            ('mask_attack', 'Mask Attack'),
            ('rule_based', 'Rule-based Attack'),
            ('dictionary', 'Dictionary Attack'),
            ('sequential_limited', 'Limited Brute Force')
        ]
        
        for i, (key, label) in enumerate(attacks):
            self.attack_vars[key] = tk.BooleanVar(value=True)
            row = i // 2
            col = i % 2
            
            cb = ttk.Checkbutton(attacks_frame, text=label,
                               variable=self.attack_vars[key],
                               style='Custom.TCheckbutton')
            cb.grid(row=row, column=col, sticky='w', padx=(0, 20), pady=2)
        
        # Personal info section
        personal_frame = ttk.LabelFrame(self.test_frame, text="Personal Information (for Social Engineering)", padding=10)
        personal_frame.pack(fill='x', pady=(0, 10))
        
        # Create entry fields for personal info
        self.personal_vars = {}
        personal_fields = [
            ('first_name', 'First Name'),
            ('last_name', 'Last Name'),
            ('birth_year', 'Birth Year'),
            ('company', 'Company'),
            ('pet_name', 'Pet Name'),
            ('city', 'City')
        ]
        
        for i, (key, label) in enumerate(personal_fields):
            row = i // 2
            col = i % 2
            
            field_frame = ttk.Frame(personal_frame)
            field_frame.grid(row=row, column=col, sticky='ew', padx=(0, 10), pady=2)
            
            ttk.Label(field_frame, text=f"{label}:",
                     style='Custom.TLabel', width=12).pack(side='left')
            
            self.personal_vars[key] = tk.StringVar()
            ttk.Entry(field_frame, textvariable=self.personal_vars[key],
                     width=15, style='Custom.TEntry').pack(side='left', fill='x', expand=True)
        
        personal_frame.grid_columnconfigure(0, weight=1)
        personal_frame.grid_columnconfigure(1, weight=1)
        
        # Control buttons
        control_frame = ttk.Frame(self.test_frame)
        control_frame.pack(fill='x', pady=(10, 0))
        
        self.test_button = ttk.Button(control_frame, text="Start Test",
                                     command=self.start_test,
                                     style='Custom.TButton')
        self.test_button.pack(side='left')
        
        self.stop_button = ttk.Button(control_frame, text="Stop Test",
                                     command=self.stop_test,
                                     style='Custom.TButton',
                                     state='disabled')
        self.stop_button.pack(side='left', padx=(10, 0))
        
        # Progress bar
        self.progress = ttk.Progressbar(control_frame, mode='indeterminate')
        self.progress.pack(side='right', fill='x', expand=True, padx=(20, 0))
        
    def create_generator_tab(self):
        """Create the password generator tab."""
        # Generator settings
        settings_frame = ttk.LabelFrame(self.generator_frame, text="Generator Settings", padding=10)
        settings_frame.pack(fill='x', pady=(0, 10))
        
        # Length setting
        length_frame = ttk.Frame(settings_frame)
        length_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Label(length_frame, text="Password Length:",
                 style='Custom.TLabel').pack(side='left')
        
        self.length_var = tk.StringVar(value="16")
        length_spinbox = ttk.Spinbox(length_frame, from_=4, to=50, width=5,
                                    textvariable=self.length_var)
        length_spinbox.pack(side='left', padx=(5, 0))
        
        # Character type checkboxes
        self.char_vars = {}
        char_types = [
            ('use_lower', 'Lowercase letters (a-z)', True),
            ('use_upper', 'Uppercase letters (A-Z)', True),
            ('use_digits', 'Digits (0-9)', True),
            ('use_special', 'Special characters (!@#$...)', True)
        ]
        
        for key, label, default in char_types:
            self.char_vars[key] = tk.BooleanVar(value=default)
            ttk.Checkbutton(settings_frame, text=label,
                           variable=self.char_vars[key],
                           style='Custom.TCheckbutton').pack(anchor='w', pady=2)
        
        # Generate button
        generate_btn = ttk.Button(settings_frame, text="Generate Password",
                                 command=self.generate_password,
                                 style='Custom.TButton')
        generate_btn.pack(pady=(10, 0))
        
        # Generated password display
        display_frame = ttk.LabelFrame(self.generator_frame, text="Generated Password", padding=10)
        display_frame.pack(fill='x', pady=(0, 10))
        
        self.generated_password_var = tk.StringVar()
        generated_frame = ttk.Frame(display_frame)
        generated_frame.pack(fill='x')
        
        self.generated_entry = ttk.Entry(generated_frame, 
                                        textvariable=self.generated_password_var,
                                        font=('Courier', 12), 
                                        style='Custom.TEntry',
                                        state='readonly')
        self.generated_entry.pack(side='left', fill='x', expand=True)
        
        copy_btn = ttk.Button(generated_frame, text="Copy",
                             command=self.copy_generated_password,
                             style='Custom.TButton')
        copy_btn.pack(side='right', padx=(5, 0))
        
        test_generated_btn = ttk.Button(generated_frame, text="Test This Password",
                                       command=self.test_generated_password,
                                       style='Custom.TButton')
        test_generated_btn.pack(side='right', padx=(5, 0))
        
        # Password strength preview
        preview_frame = ttk.LabelFrame(self.generator_frame, text="Quick Analysis", padding=10)
        preview_frame.pack(fill='both', expand=True)
        
        self.preview_text = scrolledtext.ScrolledText(preview_frame, height=10,
                                                     bg='#1e1e1e', fg='#ffffff',
                                                     font=('Courier', 10))
        self.preview_text.pack(fill='both', expand=True)
        
    def create_results_tab(self):
        """Create the results display tab."""
        # Results display
        self.results_text = scrolledtext.ScrolledText(self.results_frame, 
                                                     bg='#1e1e1e', fg='#ffffff',
                                                     font=('Courier', 10))
        self.results_text.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Control buttons
        results_control_frame = ttk.Frame(self.results_frame)
        results_control_frame.pack(fill='x', padx=10, pady=(0, 10))
        
        clear_btn = ttk.Button(results_control_frame, text="Clear Results",
                              command=self.clear_results,
                              style='Custom.TButton')
        clear_btn.pack(side='left')
        
        save_btn = ttk.Button(results_control_frame, text="Save Results",
                             command=self.save_results,
                             style='Custom.TButton')
        save_btn.pack(side='left', padx=(10, 0))
        
    def toggle_password_visibility(self):
        """Toggle password visibility in the entry field."""
        if self.show_password_var.get():
            self.password_entry.configure(show='')
        else:
            self.password_entry.configure(show='*')
            
    def generate_password(self):
        """Generate a random password based on settings."""
        try:
            length = int(self.length_var.get())
            
            chars = ""
            if self.char_vars['use_lower'].get():
                chars += string.ascii_lowercase
            if self.char_vars['use_upper'].get():
                chars += string.ascii_uppercase
            if self.char_vars['use_digits'].get():
                chars += string.digits
            if self.char_vars['use_special'].get():
                chars += string.punctuation
                
            if not chars:
                messagebox.showwarning("Warning", "Please select at least one character type!")
                return
                
            password = ''.join(random.choice(chars) for _ in range(length))
            self.generated_password_var.set(password)
            
            # Show quick analysis
            self.show_password_preview(password)
            
        except ValueError:
            messagebox.showerror("Error", "Please enter a valid password length!")
            
    def show_password_preview(self, password):
        """Show a quick preview analysis of the password."""
        self.preview_text.delete(1.0, tk.END)
        
        analysis = f"Password: {password}\n"
        analysis += f"Length: {len(password)} characters\n"
        analysis += f"Character types used: {', '.join(self.get_character_types(password))}\n\n"
        
        # Estimate strength
        entropy = self.calculate_entropy(password)
        analysis += f"Estimated entropy: {entropy:.1f} bits\n"
        
        if entropy < 30:
            strength = "Very Weak"
        elif entropy < 50:
            strength = "Weak" 
        elif entropy < 70:
            strength = "Fair"
        elif entropy < 90:
            strength = "Strong"
        else:
            strength = "Very Strong"
            
        analysis += f"Estimated strength: {strength}\n\n"
        analysis += "Note: This is a quick estimate. Use 'Test This Password' for detailed analysis."
        
        self.preview_text.insert(tk.END, analysis)
        
    def calculate_entropy(self, password):
        """Calculate password entropy."""
        charset_size = 0
        
        if any(c.islower() for c in password):
            charset_size += 26
        if any(c.isupper() for c in password):
            charset_size += 26
        if any(c.isdigit() for c in password):
            charset_size += 10
        if any(c in string.punctuation for c in password):
            charset_size += len(string.punctuation)
            
        if charset_size == 0:
            return 0
            
        import math
        return len(password) * math.log2(charset_size)
        
    def get_character_types(self, password):
        """Return the types of characters used in the password."""
        types = []
        
        if any(c.islower() for c in password):
            types.append("lowercase")
        if any(c.isupper() for c in password):
            types.append("uppercase")
        if any(c.isdigit() for c in password):
            types.append("digits")
        if any(c in string.punctuation for c in password):
            types.append("special characters")
            
        return types
        
    def copy_generated_password(self):
        """Copy generated password to clipboard."""
        password = self.generated_password_var.get()
        if password:
            self.root.clipboard_clear()
            self.root.clipboard_append(password)
            messagebox.showinfo("Success", "Password copied to clipboard!")
        else:
            messagebox.showwarning("Warning", "No password to copy!")
            
    def test_generated_password(self):
        """Move generated password to test tab and start testing."""
        password = self.generated_password_var.get()
        if password:
            self.password_var.set(password)
            # Switch to test tab
            notebook = self.test_frame.master
            notebook.select(0)  # Select first tab (Test Password)
        else:
            messagebox.showwarning("Warning", "No password to test!")
            
    def start_test(self):
        """Start password strength testing in a separate thread."""
        if self.is_testing:
            return
            
        password = self.password_var.get()
        if not password:
            messagebox.showwarning("Warning", "Please enter a password to test!")
            return
            
        # Get selected attack types
        selected_attacks = [key for key, var in self.attack_vars.items() if var.get()]
        if not selected_attacks:
            messagebox.showwarning("Warning", "Please select at least one attack type!")
            return
            # Update UI state
        self.is_testing = True
        self.test_button.configure(state='disabled')
        self.stop_button.configure(state='normal')
        self.progress.start()
        
        # Get personal information for social engineering
        personal_info = {}
        for key, var in self.personal_vars.items():
            value = var.get().strip()
            if value:
                personal_info[key] = value
        
        # Get security settings
        rate_limiting = self.rate_limiting_var.get()
        try:
            lockout_threshold = int(self.lockout_threshold_var.get())
        except ValueError:
            lockout_threshold = 5
            
        # Start testing thread
        self.test_thread = threading.Thread(
            target=self.run_password_test,
            args=(password, selected_attacks, personal_info, rate_limiting, lockout_threshold),
            daemon=True
        )
        self.test_thread.start()
        
    def stop_test(self):
        """Stop the current password test."""
        self.is_testing = False
        self.test_button.configure(state='normal')
        self.stop_button.configure(state='disabled')
        self.progress.stop()
        
        # Add stop message to queue
        self.queue.put(("log", "Test stopped by user.\n"))
        
    def run_password_test(self, password, selected_attacks, personal_info, rate_limiting, lockout_threshold):
        """Run password strength testing in a separate thread."""
        try:
            # Initialize login system
            login_system = DummyLoginSystem(
                password, 
                rate_limiting=rate_limiting,
                lockout_threshold=lockout_threshold
            )
            
            self.queue.put(("log", f"Starting password strength test for password: {'*' * len(password)}\n"))
            self.queue.put(("log", f"Password length: {len(password)} characters\n"))
            self.queue.put(("log", f"Security settings: Rate limiting={rate_limiting}, Lockout threshold={lockout_threshold}\n"))
            self.queue.put(("log", "=" * 60 + "\n\n"))
            
            total_attempts = 0
            password_cracked = False
            successful_attack = None
            successful_password = None
            
            # Run selected attacks
            for attack_type in selected_attacks:
                if not self.is_testing:
                    break
                    
                self.queue.put(("log", f"Running {attack_type.replace('_', ' ').title()} Attack...\n"))
                
                if attack_type == "rainbow_table":
                    cracked, attempts = self.rainbow_table_attack(login_system, password)
                elif attack_type == "social_engineering":
                    cracked, attempts = self.social_engineering_attack(login_system, password, personal_info)
                elif attack_type == "mask_attack":
                    cracked, attempts = self.mask_attack(login_system, password)
                elif attack_type == "rule_based":
                    cracked, attempts = self.rule_based_attack(login_system, password)
                elif attack_type == "dictionary":
                    cracked, attempts = self.dictionary_attack(login_system, password)
                elif attack_type == "sequential_limited":
                    cracked, attempts = self.limited_brute_force_attack(login_system, password)
                else:
                    continue
                    
                total_attempts += attempts
                
                if cracked:
                    password_cracked = True
                    successful_attack = attack_type
                    successful_password = password
                    self.queue.put(("log", f"✗ PASSWORD CRACKED with {attack_type.replace('_', ' ').title()} attack!\n"))
                    self.queue.put(("log", f"Attempts needed: {attempts}\n"))
                    break
                else:
                    self.queue.put(("log", f"✓ Password survived {attack_type.replace('_', ' ').title()} attack ({attempts} attempts)\n"))
                
                # Check if account is locked
                if login_system.get_status() == AccountStatus.LOCKED:
                    self.queue.put(("log", "Account locked due to too many failed attempts.\n"))
                    login_system.reset_lockout()  # Reset for next attack
                
                self.queue.put(("log", "\n"))
            
            # Final results
            self.queue.put(("log", "=" * 60 + "\n"))
            self.queue.put(("log", "FINAL RESULTS:\n"))
            self.queue.put(("log", "=" * 60 + "\n"))
            
            if password_cracked:
                self.queue.put(("log", f"❌ PASSWORD CRACKED!\n"))
                self.queue.put(("log", f"Successful attack: {successful_attack.replace('_', ' ').title()}\n"))
                self.queue.put(("log", f"Total attempts: {total_attempts}\n"))
                self.queue.put(("log", f"Recommendation: Use a stronger password\n"))
            else:
                self.queue.put(("log", f"✅ PASSWORD SURVIVED ALL ATTACKS!\n"))
                self.queue.put(("log", f"Total attempts made: {total_attempts}\n"))
                self.queue.put(("log", f"Password appears to be strong against common attacks\n"))
            
            # Calculate and display entropy
            entropy = self.calculate_entropy(password)
            self.queue.put(("log", f"Password entropy: {entropy:.1f} bits\n"))
            
            # Security recommendations
            self.queue.put(("log", "\nSECURITY RECOMMENDATIONS:\n"))
            recommendations = self.get_security_recommendations(password, password_cracked, successful_attack)
            for rec in recommendations:
                self.queue.put(("log", f"• {rec}\n"))
                
        except Exception as e:
            self.queue.put(("log", f"Error during testing: {str(e)}\n"))
        finally:
            self.queue.put(("complete", None))
            
    def rainbow_table_attack(self, login_system, target_password):
        """Perform rainbow table attack."""
        rainbow_table = RainbowTable()
        attempts = 0
        
        # Try to crack using rainbow table
        cracked_password = rainbow_table.crack_password(target_password)
        
        if cracked_password:
            # Found in rainbow table, try the login
            attempts += 1
            success, message = login_system.attempt_login(cracked_password)
            self.queue.put(("log", f"Found in rainbow table: {cracked_password}\n"))
            return success, attempts
        else:
            self.queue.put(("log", "Password not found in rainbow table\n"))
            return False, 0
            
    def social_engineering_attack(self, login_system, target_password, personal_info):
        """Perform social engineering attack using personal information."""
        if not personal_info:
            self.queue.put(("log", "No personal information provided for social engineering attack\n"))
            return False, 0
            
        wordlist_generator = SocialEngineeringWordlist()
        password_candidates = wordlist_generator.generate_personal_patterns(**personal_info)
        
        self.queue.put(("log", f"Generated {len(password_candidates)} password candidates from personal info\n"))
        
        attempts = 0
        for candidate in password_candidates:
            if not self.is_testing:
                break
                
            attempts += 1
            success, message = login_system.attempt_login(candidate)
            
            if success:
                return True, attempts
                
            if login_system.get_status() == AccountStatus.LOCKED:
                self.queue.put(("log", "Account locked during social engineering attack\n"))
                break
                
            if attempts % 100 == 0:
                self.queue.put(("log", f"Tried {attempts} social engineering passwords...\n"))
        
        return False, attempts
        
    def mask_attack(self, login_system, target_password):
        """Perform mask-based attack."""
        mask_attack = MaskAttack()
        masks = mask_attack.generate_mask_patterns()
        
        self.queue.put(("log", f"Testing {len(masks)} mask patterns\n"))
        
        total_attempts = 0
        
        for mask in masks:
            if not self.is_testing:
                break
                
            self.queue.put(("log", f"Testing mask: {mask}\n"))
            candidates = mask_attack.expand_mask(mask, max_combinations=500)
            
            for candidate in candidates:
                if not self.is_testing:
                    break
                    
                total_attempts += 1
                success, message = login_system.attempt_login(candidate)
                
                if success:
                    return True, total_attempts
                    
                if login_system.get_status() == AccountStatus.LOCKED:
                    self.queue.put(("log", "Account locked during mask attack\n"))
                    login_system.reset_lockout()
                    break
                    
            if total_attempts % 200 == 0:
                self.queue.put(("log", f"Tried {total_attempts} mask-based passwords...\n"))
        
        return False, total_attempts
        
    def rule_based_attack(self, login_system, target_password):
        """Perform rule-based attack on dictionary words."""
        # Common dictionary words
        dictionary_words = [
            'password', 'admin', 'user', 'login', 'welcome', 'hello', 'world',
            'computer', 'system', 'security', 'access', 'account', 'service',
            'manager', 'server', 'client', 'network', 'internet', 'website',
            'database', 'backup', 'config', 'master', 'guest', 'public',
            'private', 'secret', 'key', 'lock', 'open', 'close', 'start',
            'stop', 'begin', 'end', 'first', 'last', 'new', 'old', 'test',
            'demo', 'sample', 'example', 'default', 'standard', 'basic',
            'advanced', 'premium', 'professional', 'enterprise', 'business'
        ]
        
        rule_attack = RuleBasedAttack()
        password_candidates = rule_attack.apply_rules(dictionary_words, max_variations_per_word=10)
        
        self.queue.put(("log", f"Generated {len(password_candidates)} rule-based password candidates\n"))
        
        attempts = 0
        for candidate in password_candidates:
            if not self.is_testing:
                break
                
            attempts += 1
            success, message = login_system.attempt_login(candidate)
            
            if success:
                return True, attempts
                
            if login_system.get_status() == AccountStatus.LOCKED:
                self.queue.put(("log", "Account locked during rule-based attack\n"))
                break
                
            if attempts % 100 == 0:
                self.queue.put(("log", f"Tried {attempts} rule-based passwords...\n"))
        
        return False, attempts
        
    def dictionary_attack(self, login_system, target_password):
        """Perform dictionary attack."""
        # Extended common passwords list
        common_passwords = [
            'password', '123456', 'password123', 'admin', 'qwerty', 'abc123',
            'letmein', 'welcome', 'monkey', 'dragon', 'master', 'hello',
            'login', 'pass', 'test', 'guest', 'user', 'root', 'access',
            'secret', 'security', 'system', 'computer', 'server', 'network',
            'internet', 'website', 'database', 'backup', 'config', 'manager',
            'service', 'account', 'profile', 'public', 'private', 'demo',
            'sample', 'example', 'default', 'standard', 'basic', 'advanced',
            'premium', 'professional', 'enterprise', 'business', 'company',
            'corporation', 'organization', 'institution', 'foundation',
            '12345', '123456789', '1234567890', 'qwertyuiop', 'asdfghjkl',
            'zxcvbnm', 'football', 'baseball', 'basketball', 'soccer',
            'tennis', 'hockey', 'golf', 'swimming', 'running', 'cycling',
            'january', 'february', 'march', 'april', 'may', 'june',
            'july', 'august', 'september', 'october', 'november', 'december',
            'monday', 'tuesday', 'wednesday', 'thursday', 'friday',
            'saturday', 'sunday', 'morning', 'afternoon', 'evening', 'night',
            'spring', 'summer', 'autumn', 'winter', 'red', 'blue', 'green',
            'yellow', 'orange', 'purple', 'black', 'white', 'brown', 'pink'
        ]
        
        # Add variations with common suffixes
        variations = []
        suffixes = ['1', '123', '!', '2023', '2024', '2025', '01', '00']
        
        for word in common_passwords:
            variations.extend([word, word.upper(), word.capitalize()])
            for suffix in suffixes:
                variations.extend([word + suffix, word.capitalize() + suffix])
        
        all_passwords = common_passwords + variations
        
        self.queue.put(("log", f"Testing {len(all_passwords)} dictionary passwords\n"))
        
        attempts = 0
        for candidate in all_passwords:
            if not self.is_testing:
                break
                
            attempts += 1
            success, message = login_system.attempt_login(candidate)
            
            if success:
                return True, attempts
                
            if login_system.get_status() == AccountStatus.LOCKED:
                self.queue.put(("log", "Account locked during dictionary attack\n"))
                break
                
            if attempts % 50 == 0:
                self.queue.put(("log", f"Tried {attempts} dictionary passwords...\n"))
        
        return False, attempts
        
    def limited_brute_force_attack(self, login_system, target_password):
        """Perform limited brute force attack (short passwords only)."""
        max_length = min(6, len(target_password))  # Only try short passwords
        charset = string.ascii_lowercase + string.digits
        
        self.queue.put(("log", f"Trying brute force for passwords up to {max_length} characters\n"))
        
        attempts = 0
        max_attempts = 10000  # Limit to prevent excessive runtime
        
        for length in range(1, max_length + 1):
            if not self.is_testing or attempts >= max_attempts:
                break
                
            for candidate_tuple in itertools.product(charset, repeat=length):
                if not self.is_testing or attempts >= max_attempts:
                    break
                    
                candidate = ''.join(candidate_tuple)
                attempts += 1
                
                success, message = login_system.attempt_login(candidate)
                
                if success:
                    return True, attempts
                    
                if login_system.get_status() == AccountStatus.LOCKED:
                    self.queue.put(("log", "Account locked during brute force attack\n"))
                    return False, attempts
                    
                if attempts % 1000 == 0:
                    self.queue.put(("log", f"Tried {attempts} brute force combinations...\n"))
        
        return False, attempts
        
    def get_security_recommendations(self, password, was_cracked, successful_attack):
        """Generate security recommendations based on test results."""
        recommendations = []
        
        if was_cracked:
            recommendations.append(f"Password was cracked using {successful_attack.replace('_', ' ')} - use a more complex password")
            
            if successful_attack == "rainbow_table":
                recommendations.append("Avoid common passwords that appear in breach databases")
                recommendations.append("Use longer passwords with mixed character types")
                
            elif successful_attack == "social_engineering":
                recommendations.append("Avoid using personal information in passwords")
                recommendations.append("Don't use names, birthdays, or other personal details")
                
            elif successful_attack == "dictionary":
                recommendations.append("Avoid dictionary words and common passwords")
                recommendations.append("Use passphrases or random character combinations")
                
            elif successful_attack == "mask_attack":
                recommendations.append("Avoid predictable patterns (e.g., word + numbers)")
                recommendations.append("Use truly random password generation")
                
        else:
            recommendations.append("Password survived all tested attacks - appears to be strong")
            
        # General recommendations
        if len(password) < 12:
            recommendations.append("Consider using passwords of at least 12 characters")
            
        if not any(c.isupper() for c in password):
            recommendations.append("Include uppercase letters for better security")
            
        if not any(c.islower() for c in password):
            recommendations.append("Include lowercase letters for better security")
            
        if not any(c.isdigit() for c in password):
            recommendations.append("Include digits for better security")
            
        if not any(c in string.punctuation for c in password):
            recommendations.append("Include special characters for better security")
            
        # Universal recommendations
        recommendations.extend([
            "Use a unique password for each account",
            "Consider using a password manager",
            "Enable two-factor authentication when available",
            "Regularly update passwords for critical accounts"
        ])
        
        return recommendations
        
    def check_queue(self):
        """Process messages from the testing thread."""
        try:
            while True:
                message_type, content = self.queue.get_nowait()
                
                if message_type == "log":
                    self.results_text.insert(tk.END, content)
                    self.results_text.see(tk.END)
                elif message_type == "complete":
                    self.is_testing = False
                    self.test_button.configure(state='normal')
                    self.stop_button.configure(state='disabled')
                    self.progress.stop()
                    
        except queue.Empty:
            pass
        finally:
            # Schedule next check
            self.root.after(100, self.check_queue)
            
    def clear_results(self):
        """Clear the results display."""
        self.results_text.delete(1.0, tk.END)
        
    def save_results(self):
        """Save results to a file."""
        from tkinter import filedialog
        
        content = self.results_text.get(1.0, tk.END)
        if not content.strip():
            messagebox.showwarning("Warning", "No results to save!")
            return
            
        filename = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            title="Save Results"
        )
        
        if filename:
            try:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                messagebox.showinfo("Success", f"Results saved to {filename}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save file: {str(e)}")

def main():
    """Main function to run the application."""
    root = tk.Tk()
    app = PasswordStrengthGUI(root)
    
    # Center the window
    root.update_idletasks()
    width = root.winfo_width()
    height = root.winfo_height()
    x = (root.winfo_screenwidth() // 2) - (width // 2)
    y = (root.winfo_screenheight() // 2) - (height // 2)
    root.geometry(f"{width}x{height}+{x}+{y}")
    
    root.mainloop()

if __name__ == "__main__":
    main()